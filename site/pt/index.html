<!DOCTYPE html><html lang="pt"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="A Guide to JavaScript's Quirks and Flaws."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/JavaScript-Garden/favicon.ico?v=2"><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]--></head><body><!-- Navigation--><nav id="nav_main"><div><ul> <li><a href="/JavaScript-Garden/" title="JavaScript Garden">en</a></li><li><a href="/JavaScript-Garden/es" title="Jardín de JavaScript">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha">fi</a></li><li><a href="/JavaScript-Garden/hu" title="JavaScript Garden">hu</a></li><li><a href="/JavaScript-Garden/it" title="JavaScript Garden">it</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden">pl</a></li><li class="active"><a href="/JavaScript-Garden/pt" title="JavaScript Garden">pt</a></li><li><a href="/JavaScript-Garden/ru" title="JavaScript Гарден">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript 秘密花园">zh</a></li><li><a href="/JavaScript-Garden/zhtw" title="JavaScript 庭院">zhtw</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Introdução</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">Objetos</a></h1><ul><li><a href="#object.general">Uso de objetos e propriedades</a></li><li><a href="#object.prototype">O Prototype</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">O Loop <code>for in</code></a></li></ul></li><li class="nav_function"><h1><a href="#function">Funções</a></h1><ul><li><a href="#function.general">Declarações de Funções e Expressões</a></li><li><a href="#function.this">Como Funciona o <code>this</code></a></li><li><a href="#function.closures"><em>Closures</em> e Referências</a></li><li><a href="#function.arguments">O Objeto <code>arguments</code></a></li><li><a href="#function.constructors">Construtores</a></li><li><a href="#function.scopes">Scopes and Namespaces</a></li></ul></li><li class="nav_array"><h1><a href="#array">Arrays</a></h1><ul><li><a href="#array.general">Array Iteration and Properties</a></li><li><a href="#array.constructor">The <code>Array</code> Constructor</a></li></ul></li><li class="nav_types"><h1><a href="#types">Types</a></h1><ul><li><a href="#types.equality">Equality and Comparisons</a></li><li><a href="#types.typeof">The <code>typeof</code> Operator</a></li><li><a href="#types.instanceof">The <code>instanceof</code> Operator</a></li><li><a href="#types.casting">Type Casting</a></li></ul></li><li class="nav_core"><h1><a href="#core">Core</a></h1><ul><li><a href="#core.eval">Why Not to Use <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> and <code>null</code></a></li><li><a href="#core.semicolon">Automatic Semicolon Insertion</a></li><li><a href="#core.delete">The <code>delete</code> Operator</a></li></ul></li><li class="nav_other"><h1><a href="#other">Outros</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> and <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Introdução</h1></header><!-- Articles--><article id="intro.index"><h2>Intro</h2><div><p><strong>JavaScript Garden</strong> é uma coleção em evolução de documentação sobre as 
partes mais peculiares da linguagem de programação JavaScript. Ela fornece 
conselhos a fim de evitar erros comuns e <i>bugs</i> sutis, bem como 
problemas de perfomance e práticas ruins, que programadores que não sejam 
especialistas podem encontrar nos seus esforços e estudos nas profundezas 
da linguagem.</p>
<p>JavaScript Garden não visa lhe ensinar JavaScript. Um conhecimento prévio 
da linguagem é fortemente recomendado a fim de compreender os tópicos 
abordados nesse guia. A fim de aprender os conceitos básicos da linguagem, 
por favor, leia o excelente <a href="https://developer.mozilla.org/en/JavaScript/Guide">guia</a> na MDN - Mozilla Developer Network.</p>
<h2 id="os-autores">Os autores</h2>
<p>Esse guia é trabalho de dois encantadores usuários do 
<a href="http://stackoverflow.com/">Stack Overflow</a>, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a> (escrita) e <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (design).</p>
<p>Atualmente é mantido por <a href="http://truffles.me.uk">Tim Ruffles</a>.</p>
<h2 id="contribu-dores">Contribuídores</h2>
<ul>
<li>São muitos para listar aqui, <a href="https://github.com/BonsaiDen/JavaScript-Garden/graphs/contributors">veja todos os contribuídores</a>.</li>
</ul>
<h2 id="hospedagem">Hospedagem</h2>
<p>JavaScript Garden está hospedado no GitHub, mas a <a href="http://cramerdev.com/">Cramer Development</a> 
nos dá suporte com um espelho em <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p>
<h2 id="licen-a">Licença</h2>
<p>JavaScript Garden é publicado sob a <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">licença MIT</a> e hospedado no 
<a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. Se você encontrar erros nas explicações ou de digitação, 
por favor <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">submeta uma issue</a> ou um <i>pull request</i> no repositório. 
Você também pode nos encontrar no <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavaScript room</a> no chat 
do Stack Overflow.</p>
</div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Objetos</h1></header><!-- Articles--><article id="object.general"><h2>Uso de objetos e propriedades</h2><div><p>Tudo no JavaScript atua como um objeto, com apenas duas exceções sendo 
<a href="#core.undefined"><code>null</code></a> e <a href="#core.undefined"><code>undefined</code></a>.</p>
<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1</code></pre>
<p>Um equívoco comum é que números literais não podem ser usados como objetos. 
Isso porque uma falha no <em>parser</em> do JavaScript tenta reconhecer a notação 
de ponto em um número como um ponto flutuante literal.</p>
<pre><code>2.toString(); // gera um SyntaxError</code></pre>
<p>Existem algumas maneiras que podem ser usadas para fazer números literais 
atuarem como objetos também.</p>
<pre><code>2..toString(); // o segundo ponto é reconhecido corretamente
2 .toString(); // note o espaço à esquerda do ponto
(2).toString(); // 2 é avaliado primeiro</code></pre>
<h3 id="objects-como-um-tipo-de-dados-data-type-">Objects como um tipo de dados (<em>Data Type</em>)</h3>
<p>Objetos em JavaScript podem também ser usados com <a href="http://en.wikipedia.org/wiki/Hashmap"><em>Hashmaps</em></a>; eles 
consistem principalmente do mapeamento de propriedades e valores.</p>
<p>Usando um objeto literal - notação <code>{}</code> - é possível criar um objeto simples.
Esse novo objeto <a href="#object.prototype">herda</a> de <code>Object.prototype</code> e não tem 
<a href="#object.hasownproperty">propriedades próprias</a> definidas.</p>
<pre><code>var foo = {}; // um novo objeto em branco

// um novo objeto com uma propriedade &#39;test&#39; com valor 12
var bar = {test: 12}; </code></pre>
<h3 id="acessando-propriedades">Acessando Propriedades</h3>
<p>As propriedades de um objeto podem ser acessadas de duas maneiras, 
via pela notação ponto ou pela notação colchete.</p>
<pre><code>var foo = {name: &#39;kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // works</code></pre>
<p>As notações trabalham de forma quase idêntica, com a única diferença 
sendo que a notação de colchete permite a configuração dinâmica de 
propriedades e o uso de nomes de propriedades que, de outra forma, 
levariam a um erro de sintaxe.</p>
<h3 id="excluindo-propriedades">Excluindo Propriedades</h3>
<p>A única maneira de remover uma propriedade de um objeto é usar o operador 
<code>delete</code>; setando a propriedade para <code>undefined</code> ou <code>null</code> apenas remove o 
<em>valor</em> associado à propriedade, mas não a <em>chave</em> (<em>key</em>).</p>
<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}</code></pre>
<p>O código acima tem como resultado ambos: <code>bar undefined</code> e <code>foo null</code> - 
apenas <code>baz</code> foi removida e portanto está ausente do <em>output</em> do código.</p>
<h3 id="nota-o-de-chaves">Notação de chaves</h3>
<pre><code>var test = {
    &#39;case&#39;: &#39;Eu sou uma keyword, portanto devo ser anotada 
    como uma string&#39;,
    delete: &#39;Eu sou uma keyword, portanto eu também&#39; // gera um SyntaxError
};</code></pre>
<p>Propriedades de objetos podem ser anotadas como caracteres simples e strings. 
Devido a outro <em>mis-design</em> no <em>parser</em> do JavaScrpt, o código acima irá 
mostrar um <code>SyntaxError</code>
antes do ECMAScript 5.</p>
<p>Este erro decorre do fato de que <code>delete</code> é uma <em>palavra-chave</em>; portanto, 
deve ser anotada como uma <em>string literal</em> para garantir que irá ser 
corretamente interpretada por motores JavaScript mais antigos.</p>
</div></article><article id="object.prototype"><h2>O Prototype</h2><div><p>JavaScript não tem um modelo de herança clássica; em vez disso, utiliza
uma baseada no <em>prototype</em>.</p>
<p>Enquanto isso é muitas vezes considerado como um dos pontos fracos do
JavaScript, o modelo de herança de protótipo é de fato mais potente
que o o modelo clássico. Por exemplo, é relativamente simples
desenvolver um modelo clássico sob o modelo <i>prototype</i>, 
enquanto o contrário é uma tarefa muito mais difícil.</p>
<p>JavaScript é a única linguagem usada amplamente que apresenta herança pelo
<i>prototype</i>, por isso pode levar algum tempo para ajustar-se às
diferenças entre os dois modelos.</p>
<p>A primeira grande diferença é que herança em JavaScript utiliza <em>prototype
chains</em>.</p>
<aside>
<p><strong>Nota:</strong> Simplesmente usando <code>Bar.prototype = Foo.prototype</code> resultará 
em ambos objetos compartilhamento o <strong>mesmo</strong> <em>prototype</em>. Portanto, 
alterar o <em>prototype</em> de um objeto irá afetar o <em>prototype</em> do outro
objeto também, o que na maioria dos casos não é o efeito desejado.</p>
</aside>
<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Seta o Bar prototype para uma nova instância Foo
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Certifique-se de listar Bar como construtor atual
Bar.prototype.constructor = Bar;

var test = new Bar(); // cria uma nova instância de bar

// O resultado de prototype chain (cadeia de prototypes)
test [instance of Bar]
    Bar.prototype [instance of Foo]
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* etc. */ }</code></pre>
<p>No código acima, o objeto <code>test</code> herdará de <code>Bar.prototype</code> e <code>Foo.prototype</code>;
portanto ele terá acesso à função <code>method</code> que foi definida em <code>Foo</code>. Ele
também tera acesso ao <code>value</code> da propriedade de <strong>uma </strong> instância de <code>Foo</code>
que é o seu <em>prototype</em>. É importante notar que a <code>new Bar()</code> <strong>não</strong> cria uma
nova instância <code>Foo</code>, mas reutiliza uma atribuída ao seu <em>prototype</em>; assim, 
todas instâncias <code>Bar</code> irão compartilhar a <strong>mesma</strong> propriedade <code>value</code>.</p>
<aside>
<p><strong>Nota:</strong> <strong>Não</strong> use <code>Bar.prototype = Foo</code>, uma vez que não irá apontar para
o <em>prototype</em> de <code>Foo</code> mas sim ao objeto função <code>Foo</code>. Assim, o
a cadeia de <em>prototype</em> vai se sobrepor a <code>Function.prototype</code> e não 
<code>Foo.prototype</code>; portanto, <code>method</code> não estará na cadeia de <em>prototype</em>.</p>
</aside>
<h3 id="propriedade-lookup-">Propriedade <em>Lookup</em></h3>
<p>Ao acessar as propriedades de um objeto, JavaScript irá percorrer a cadeia do
<em>prototype</em> para cima até achar a propriedade com o nome solicitado.</p>
<p>Se atingir o topo da cadeia - nomeada <code>Object.prototype</code> - e ainda não tiver
encontrado a propriedade específica, ele irá retornar o valor
<a href="#core.undefined">undefined</a> no lugar.</p>
<h3 id="a-propriedade-prototype">A Propriedade Prototype</h3>
<p>Enquanto a propriedade <em>prototype</em> é usada pela linguagem para construir a 
cadeira <em>prototype</em>, ainda é possível atribuir qualquer a ela. No entanto,
os primitivos serão simplemesmente ignorados quando atribuídos como
<em>prototype</em>.</p>
<pre><code>function Foo() {}
Foo.prototype = 1; // sem efeito</code></pre>
<p>Atribuindo objetos, como mostrado no exemplo acima, irá funcionar e permite
a criação dinâmica de cadeias <em>prototype</em>.</p>
<h3 id="performance">Performance</h3>
<p>O tempo de pesquisa para as propriedades que estão no topo da cadeia 
<em>prototype</em> pode ter um impacto negativo na performance e, isso pode ser
significativo em códigos que o desempenho é crítico. Além disso, tentar 
acessar propriedades inexistentes irá sempre percorrer a cadeia 
<em>prototype</em> inteira.</p>
<p>Além disso, quando se <a href="#object.forinloop">itera</a> sobre as propriedades 
de um objeto, <strong>cada</strong> propriedade que está na cadeia será enumerada.</p>
<h3 id="extens-o-de-prototypes-nativos">Extensão de <em>Prototypes</em> nativos</h3>
<p>Uma característica inconveniente que é frequentemente usada é estender 
<code>Object.prototype</code> ou um dos outros contruídos em <em>prototype</em>.</p>
<p>Essa técnica é chamada <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> e quebra o <em>encapsulamento</em>. 
Enquanto é usado por frameworks populares como o <a href="http://prototypejs.org/">Prototype</a>, ainda não há 
uma boa razão sobrecarregar tipos internos (<em>built-in types</em>) com 
funcionalidades adicionais <em>não padrão</em>.</p>
<p>A <strong>única</strong> boa razão para estender um <em>prototype</em> interno é para transportar
as funcionalidades para novos motores JavaScript; por exemplo,
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>.</p>
<h3 id="conclus-o">Conclusão</h3>
<p>É <strong>essencial</strong> entender o modelo de herança baseado em <em>prototype</em> antes de
escrever códigos complexos que fazem uso dela. Além disso, esteja ciente 
do tamanho das cadeias <em>prototype</em> no seu código e quebre elas, se 
necessário, para evitar possíveis problemas de desempenho. Outro ponto, os
<em>prototypes</em> nativos <strong>nunca</strong> devem ser estendidos a menos que seja por uma
questão de compatibilidade com novas funcionalidades JavaScript.</p>
</div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>Para verificar se um objeto possui uma propriedade definida em si e não em 
algum lugar da <a href="#object.prototype">cadeia prototype</a>, é necessário utilizar o 
método <code>hasOwnProperty</code> que todos objetos herdam de <code>Object.prototype</code>.</p>
<aside>
<p><strong>Nota:</strong> <strong>Não</strong> é suficiente verificar se uma propriedade é <code>undefined</code>. 
A propriedade pode existir, mas seu valor é setado para <code>undefined</code>.</p>
</aside>
<p><code>hasOwnProperty</code> é a única coisa no JavaScript que trata de propriedades e que 
<strong>não</strong> percorre a cadeira <em>prototype</em>.</p>
<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1;
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true</code></pre>
<p>Só <code>hasOwnProperty</code> irá dar o correto e esperado resultado; isso é essencial 
quando ocorre iteração sobre as propriedades de qualquer objeto. <strong>Não</strong> há 
nenhuma outra maneira de excluir proriedades que não estão definidadas no 
próprio objeto, mas em algum lugar da cadeia <em>prototype</em>.</p>
<h3 id="-hasownproperty-como-uma-propriedade"><code>hasOwnProperty</code> como uma Propriedade</h3>
<p>JavaScript não protege o nome da propriedade <code>hasOwnProperty</code>; assim, se a 
possibilidade existe de um objeto ter uma propriedade com esse nome, é 
necessário usar um <code>hasOwnProperty</code> <em>externo</em> para se obter resultados 
corretos.</p>
<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // sempre retorna false

// Use outro objeto hasOwnProperty e chame-o com o &#39;this&#39; definido para foo
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// Também é possível usar hasOwnProperty do Object prototype
// para esse propósito
Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // true</code></pre>
<h3 id="conclus-o">Conclusão</h3>
<p>Usar <code>hasOwnProperty</code> é a <strong>única</strong> maneira confiável para verificar a 
existência de uma propriedade em um objeto. Recomenda-se que <code>hasOwnProperty</code> 
seja usado em <strong>cada</strong> <a href="#object.forinloop"><code>for in</code> loop</a> para evitar erros 
de <a href="#object.prototype">prototypes</a> nativos estendidos.</p>
</div></article><article id="object.forinloop"><h2>O Loop <code>for in</code></h2><div><p>Assim como no operador <code>in</code>, o loop <code>for in</code> percorre a cadeia <em>prototype</em> 
quando itera sobre as propriedades de um objeto.</p>
<aside>
<p><strong>Nota:</strong> O loop <code>for in</code> <strong>não</strong> irá iterar sobre quaisquer propriedades 
que têm seus atributos <code>enumeráveis</code> definidos como <code>false</code>; por exemplo, a 
propriedade <code>length</code> de um array.</p>
</aside>
<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // resulta em ambos: bar e moo
}</code></pre>
<p>Uma vez que não é possível alterar o comportamento do loop <code>for in</code> em si, 
é necessário filtrar as propriedades indesejadas dentro do loop;sso é feito 
usando o método <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> do 
<code>Object.prototype</code>.</p>
<aside>
<p><strong>Nota:</strong> Como o <code>for in</code> percorre a cadeia <em>prototype</em> completa, cada 
camada de herança adiciona ao objeto, deixará a execução mais lenta.</p>
</aside>
<h3 id="usando-hasownproperty-para-filtragem">Usando <code>hasOwnProperty</code> para Filtragem</h3>
<pre><code>// o mesmo foo acima
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}</code></pre>
<p>Essa versão é a única correta a se usar. Devido ao uso do <code>hasOwnProperty</code>, 
<strong>apenas</strong> será impresso <code>moo</code>. Quando <code>hasOwnProperty</code> não é utilizado, o 
código é propenso a erros em casos onde <em>prototypes</em> nativos - e.g. 
<code>Object.prototype</code> - são estendidos.</p>
<p>Um framework muito utilizado que estende o <code>Object.prototype</code> é o 
<a href="http://www.prototypejs.org/">Prototype</a>. Quando esse framework está incluído, os loops <code>for in</code> que 
não usam <code>hasOwnProperty</code> estão garantidos a quebrar.</p>
<h3 id="conclus-o">Conclusão</h3>
<p>Recomenda-se <strong>sempre</strong> usar <code>hasOwnProperty</code>. Nunca devem ser feitos 
pressupostos sobre o ambiente em que o código está sendo executado, ou se 
os <em>prototypes</em> nativos foram estendidos ou não.</p>
</div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Funções</h1></header><!-- Articles--><article id="function.general"><h2>Declarações de Funções e Expressões</h2><div><p>Funções no JavaScript são objetos de primeira classe. Isso significa que podem 
ser passados como qualquer outro valor. Um uso comum para essa funcionalidade 
é passar uma <em>função anônima</em> como <em>callback</em> para outra, possivelmente 
uma função assíncrona.</p>
<h3 id="a-declara-o-function-">A Declaração <code>function</code></h3>
<pre><code>function foo() {}</code></pre>
<p>A função acima é <a href="#function.scopes">elevada (<em>hoisting</em>)</a> antes da execução 
do programa iniciar; assim, ela está disponível <em>em todo lugar</em> no escopo que 
foi <em>definida</em>, mesmo se for chamada antes da sua definição no arquivo.</p>
<pre><code>foo(); // Funciona pois foo foi criada antes do código ser executado
function foo() {}</code></pre>
<h3 id="a-express-o-function-">A Expressão <code>function</code></h3>
<pre><code>var foo = function() {};</code></pre>
<p>Esse exemplo atribui uma função sem nome e <em>anônima</em> para a variável <code>foo</code>.</p>
<pre><code>foo; // &#39;undefined&#39;
foo(); // isso gera um TypeError
var foo = function() {};</code></pre>
<p>Devido ao fato de <code>var</code> ser uma declaração que eleva a variável <code>foo</code> antes 
da real execução do código iniciar, <code>foo</code> já está declarada quando o script 
é executado.</p>
<p>Mas desde que atribuições só acontecem durante a execução, o valor de <code>foo</code> 
será por padrão <a href="#core.undefined">undefined</a>, antes do código correspondente 
ser executado.</p>
<h3 id="express-es-de-fun-es-nomeadas">Expressões de Funções Nomeadas</h3>
<p>Outro caso especial é a atribuição de funções nomeadas.</p>
<pre><code>var foo = function bar() {
    bar(); // Funciona
}
bar(); // ReferenceError</code></pre>
<p>Aqui, <code>bar</code> não está disponível no escopo externo, uma vez que a função só 
fica atribuida a <code>foo</code>; no entanto, dentro de <code>bar</code>, ela é disponível. 
Isso é devido a como a <a href="#function.scopes">resolução de nomes</a> 
funciona no JavaScript, o nome da função é <em>sempre</em> disponível no escopo 
local da própria função.</p>
</div></article><article id="function.this"><h2>Como Funciona o <code>this</code></h2><div><p>JavaScript tem um conceito diferente sobre o que a palavra especial <code>this</code> se 
refere em relação à maioria das outras linguagens de programação. Existem 
exatamente <strong>cinco</strong> diferentes maneiras que o valor de <code>this</code> pode ser 
ligado à linguagem.</p>
<h3 id="o-escopo-global">O Escopo Global</h3>
<pre><code>this;</code></pre>
<p>Quando o <code>this</code> é usaodo no escopo global, ele vai simplesmente se referir 
ao objeto <em>global</em>.</p>
<h3 id="chamando-uma-fun-o">Chamando uma Função</h3>
<pre><code>foo();</code></pre>
<p>Aqui, <code>this</code> irá se referir novamente ao objeto <em>global</em>.</p>
<aside>
<p><strong>Nota ES5:</strong> No <em>strict mode</em>, o processo global <strong>não existe</strong>. Nesse caso,
<code>this</code> terá o valor <code>undefined</code>.</p>
</aside>
<h3 id="chamando-um-m-todo">Chamando um Método</h3>
<pre><code>test.foo(); </code></pre>
<p>Nesse exemplo, <code>this</code> irá se referir a <code>test</code>.</p>
<h3 id="chamando-um-construtor">Chamando um Construtor</h3>
<pre><code>new foo(); </code></pre>
<p>Uma chamada de função que é precedida pela keyword <code>new</code> atua como um 
<a href="#function.constructors">construtor</a>. Dentro da função, <code>this</code> irá se referir 
ao objeto <em>recém criado</em>.</p>
<h3 id="defini-o-expl-cita-do-this-">Definição Explícita do <code>this</code></h3>
<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // array se expandiá para baixo
foo.call(bar, 1, 2, 3); // resulta em a = 1, b = 2, c = 3</code></pre>
<p>Ao usar os métodos <code>call</code> ou <code>apply</code> de <code>Function.prototype</code>, o valor de 
<code>this</code> dentro da função chamada é definido explicitamente para o primeiro 
argumento função correspondente.</p>
<p>Como resultado, no exemplo acima, o <em>exemplo de método</em> <strong>não</strong> é aplicado e, 
<code>this</code> dentro <code>foo</code> será definido como <code>bar</code>. </p>
<aside>
<p><strong>Nota:</strong> <code>this</code> <strong>não pode</strong> ser usado para se referir ao objeto dentro de
objeto literal. Portanto, <code>var obj = {me: this}</code> <strong>não</strong> irá resultar em
<code>me</code> referindo-se a <code>obj</code>, uma vez que <code>this</code> só está vinculado a um dos 
cinco casos listados.</p>
</aside>
<h3 id="problemas-comuns">Problemas Comuns</h3>
<p>Enquanto a maioria desses casos faz sentido, o primeiro pode ser considerado 
uma falha de design da linguagem porque <strong>nunca</strong> tem qualquer uso prático.</p>
<pre><code>Foo.method = function() {
    function test() {
        // this é definido ao objeto global
    }
    test();
}</code></pre>
<p>Um equívoco comum é que <code>this</code> dentro de <code>test</code> refere-se a <code>Foo</code>; o que de 
fato <strong>não</strong> acontece.</p>
<p>A fim de ter acesso a <code>Foo</code> dentro de <code>test</code>, é necessário criar uma 
variável local dentro de <code>method</code> que refere-se a <code>Foo</code>.</p>
<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Use that ao invés de this aqui
    }
    test();
}</code></pre>
<p><code>that</code> é apenas uma variável normal, mas é comumente usada para referenciar 
um <code>this</code>exterior. Em combinação com as <a href="#function.closures">closures</a>, pode 
também ser usado para passar valores de <code>this</code> para outras partes.</p>
<h3 id="atribui-o-de-m-todos">Atribuição de Métodos</h3>
<p>Outra coisa que <strong>não</strong> funciona no JavaScript é <em>function aliasing</em>, que é 
<strong>atribuir</strong> um método a uma variável.</p>
<pre><code>var test = someObject.methodTest;
test();</code></pre>
<p>Devido ao primeiro caso, <code>test</code> agora age como uma chamda de função simples; 
portanto, o <code>this</code> interior não se refere a <code>someObject</code>.</p>
<p>Enquanto a vinculação tardia de <code>this</code> pode parecer a princípio uma má idéia, 
na verdade, é o que faz a <a href="#object.prototype">herança prototype</a> 
funcionar. </p>
<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();</code></pre>
<p>Quando <code>method</code> é chamado em uma instância de <code>Bar</code>, <code>this</code> irá se referir 
àquela exata instância.</p>
</div></article><article id="function.closures"><h2><em>Closures</em> e Referências</h2><div><p>Um dos recursos mais poderosos no JavaScript é a disponibilidade de <em>closures</em>.
Com closures, escopos <strong>sempre</strong> mantém acesso ao escopo externo, em que foram
definidos. Uma vez que que o único escopo que o JavaScript possuim é o 
<a href="#function.scopes">escopo de função</a>, todas funções, por padrão, atuam 
como closures.</p>
<h3 id="emulando-vari-veis-privadas">Emulando variáveis privadas</h3>
<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5</code></pre>
<p>Aqui, <code>Counter</code> retorna <strong>duas</strong> closures: a função <code>increment</code> e a função 
<code>get</code>. Ambas funções mantém a <strong>referência</strong> ao escopo de <code>Counter</code> e, 
por isso, sempre mantém acesso à variável <code>count</code> que foi definida naquele 
escopo.</p>
<h3 id="porque-vari-veis-privadas-funcionam">Porque Variáveis Privadas Funcionam</h3>
<p>Como não é possível referenciar ou atribuir escopos em JavaScript, <strong>não</strong> 
existe maneira de acessar a variável <code>count</code> de fora. A única maneira de 
com a variável é por meio das duas closures.</p>
<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};</code></pre>
<p>O código acima <strong>não</strong> irá alterar a variável <code>count</code> no escopo <code>Counter</code>, 
uma vez que <code>foo.hack</code> não foi definido <strong>naquele</strong> escopo. Ao invés disso, 
será criada - ou sobre ou sobreposta - a variável <em>global</em> <code>count</code>.</p>
<h3 id="closures-dentro-de-loops">Closures Dentro de Loops</h3>
<p>Um erro frequente é usar closures no interior de loops, como se eles fossem 
copiar o valor da variável index do loop.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}</code></pre>
<p>O código acima <strong>não</strong> irá mostrar os números de <code>0</code> até <code>9</code>, mas irá 
simplesmente imprimir o número <code>10</code> dez vezes.</p>
<p>A função <em>anônima</em> mantém <strong>referência</strong> a <code>i</code>. No momento que <code>console.log</code> 
é chamado, o <code>loop for</code> já terminou, e o valor de <code>i</code> foi definido para 10.</p>
<p>A fim de obter o comportamento desejado, é necessário criar uma <strong>cópia</strong> 
do valor de <code>i</code>.</p>
<h3 id="evitando-o-problema-da-refer-ncia">Evitando o Problema da Referência</h3>
<p>Para copiar o valor da variável index do loop, é melhor usar um 
<a href="#function.scopes"><em>wrapper</em> anônimo</a>.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}</code></pre>
<p>A função anônima externa é chamada imediatamente com <code>i</code> como seu primeiro 
argumento e receberá uma cópia do <strong>valor</strong> de <code>i</code> como seu parâmetro <code>e</code>.</p>
<p>A função anônima que é passada para <code>setTimeout</code> agora tem uma referência a 
<code>e</code>, cujo valor <strong>não</strong> é alterado pelo loop.</p>
<p>Existe uma outra maneira possível de atingir o mesmo resultado, que é 
retornar uma função do <code>wrapper</code>(invólucro) anônimo que terá então, o mesmo comportamento do código acima.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}</code></pre>
<p>Há ainda uma outra maneira de chegar no mesmo resultado usando o <code>.bind</code>, 
que pode vincular um contexto e argumentos <code>this</code> para a função. 
O comportamento é o mesmo ao código acima.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(console.log.bind(console, i), 1000);
}</code></pre>
</div></article><article id="function.arguments"><h2>O Objeto <code>arguments</code></h2><div><p>Cada escopo de função no JavaScript pode acessar a variável especial
<code>arguments</code>. Essa variável contém uma lista de todos os argumentos que 
foram passados para a função.</p>
<aside>
<p><strong>Nota:</strong> No caso de <code>arguments</code> já ter sido definido dentro do escopo da 
função, sendo por uma declaração <code>var</code> ou sendo o nome de um parâmetro 
formal, o objeto <code>arguments</code> não será criado.</p>
</aside>
<p>O objeto <code>arguments</code> <strong>não</strong> é um array. Embora ele tenha algumas das 
semânticas de um array - ou seja, a propriedade <code>length</code> - não herda de 
<code>Array.prototype</code> e é de fato um objeto.</p>
<p>Devido a isso, <strong>não</strong> é possível usar métodos padrões de array como <code>push</code>, 
<code>pop</code> ou <code>slice</code> em <code>arguments</code>. Enquanto a iteração com um simples <code>for</code> 
funciona bem, é necessário convertê-lo para um <code>Array</code> real a fim de poder 
usar os métodos padrões de <code>Array</code>.</p>
<h3 id="convertendo-para-um-array">Convertendo para um Array</h3>
<p>O código abaixo irá retornar um novo <code>Array</code> contendo todos os elementos 
do objeto <code>arguments</code>.</p>
<pre><code>Array.prototype.slice.call(arguments);</code></pre>
<p>Como essa conversão é <strong>lenta</strong>, <strong>não</strong> é recomendada usá-la em seções de 
código com desempenho crítico.</p>
<h2 id="passando-argumentos">Passando Argumentos</h2>
<p>Abaixo é a maneira recomendada para passar agumentos de uma função para outra.</p>
<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // faça coisas aqui
}</code></pre>
<p>Outra dica é usar ambos, <code>call</code> e <code>apply</code> juntos para criar <code>wrappers</code>
(invólucros) rápidos e desacoplados.</p>
<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Cria uma versão desacoplada de &quot;method&quot; 
// Leva os parâmetros: this, arg1, arg2...argN
Foo.method = function() {

    // Resultado: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};</code></pre>
<h3 id="par-metros-formais-e-ndices-de-argumentos">Parâmetros Formais e Índices de Argumentos</h3>
<p>O objeto <code>arguments</code> cria funções <em>getter</em> e <em>setter</em> tanto suas propriedades, 
como para os parâmetros formais da função.</p>
<p>Como resultado, a alteração do valor de um parâmtro formal vai alterar também 
o valor da propriedade correspondente no objeto <code>arguments</code> e vice-versa.</p>
<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);</code></pre>
<h3 id="mitos-e-verdades-sobre-perfomance">Mitos e Verdades sobre Perfomance</h3>
<p>A única vez que o objeto <code>arguments</code> não é criado é quando ele é declarado 
como um nome dentro de uma função ou um de seus parâmetros formais. Assim, 
não importa se ele é usado ou não.</p>
<p>Ambos, <em>getters</em> e <em>setters</em> são <strong>sempre</strong> criados; assim, usar eles não 
impacta no desempenho no geral, especialmente no código do mundo real, 
onde há mais de um simples acesso às propriedades do objeto <code>arguments</code>.  </p>
<aside>
<p><strong>Nota ES5:</strong> Esses <em>getters</em> e <em>setters</em> não são criados em <code>strict mode</code>.</p>
</aside>
<p>No entanto, existe um caso que reduz drasticamente o desempenho de motores
JavaScript modernos. Esse caso é o uso do <code>arguments.callee</code>.</p>
<pre><code>function foo() {
    arguments.callee; // faça algo com essa função objeto
    arguments.callee.caller; // e a chamada da função objeto
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // Normalmente será embutido
    }
}</code></pre>
<p>No código acima, <code>foo</code> já não pode ser um objeto para <a href="http://en.wikipedia.org/wiki/Inlining"><code>inlining</code></a> uma vez 
que precisa conhecer tanto a si mesmo como seu <code>caller</code>. Isso só gera 
possíveis perda de desempenho que surgem a partir do <code>inlining</code>, mas também 
quebra o encapsulamento porque a função agora precisa ser dependente de um 
contexto de chamada específico.</p>
<p>Fazer uso de <code>arguments.callee</code> e quaisquer das suas propriedades é altamente 
desencorajado.</p>
<aside>
<p><strong>Nota ES5:</strong> No <code>strict mode</code>, <code>arguments.callee</code> irá lançar um
<code>TypeError</code> uma vez que seu uso se torno obsoleto.</p>
</aside>
</div></article><article id="function.constructors"><h2>Construtores</h2><div><p>Construtores em JavaScript são mais um recurso que difere de muitas outras 
linguagens. Qualquer chamada que é precedida pela palavra chave <code>new</code> 
atua como um construtor.</p>
<p>No interior de um construtor - função chamada - o valor de <code>this</code> se refere 
ao recém objeto criado. O <a href="#object.prototype">prototype</a> desse <strong>novo</strong> 
objeto é definido como o <code>prototype</code> da função objeto que foi invocada 
como o construtor.</p>
<p>Se a função que foi chamada não tiver uma instrução <code>return</code> explícita, então 
implicitamente retorna o valor de <code>this</code> - o novo objeto.</p>
<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();</code></pre>
<p>No código acima <code>Foo</code> é chamada como um construtor e define o <code>prototype</code> 
do recém criado objeto para <code>Foo.prototype</code>.</p>
<p>No caso de uma declaração explícita de <code>return</code>, a função retorna o valor 
especificado por essa declaração, mas <strong>somente</strong> se o valor retornado 
for um <code>Object</code>.</p>
<pre><code>function Bar() {
    return 2;
}
new Bar(); // a new object

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // o objeto retornado</code></pre>
<p>Quando a palavra chave <code>new</code> for omitida, a função <strong>não</strong> irá retornar um 
novo objeto.</p>
<pre><code>function Foo() {
    this.bla = 1; // fica definida no objeto global
}
Foo(); // undefined</code></pre>
<p>Enquanto o exemplo acima pode funcionar em alguns casos, devido ao 
funcionamento do <a href="#function.this"><code>this</code></a> em JavaScript, ele usará o 
<em>objeto global</em> como valor de <code>this</code>.</p>
<h3 id="factories">Factories</h3>
<p>A fim de poder omitir a palavra chame <code>new</code>, a função construtora tem que 
retornar um valor explicitamente.</p>
<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();</code></pre>
<p>Ambas as chamadas a <code>Bar</code> retornam a mesma coisa, o objeto recém criado que 
tem uma propriedade chamada <code>method</code>, a qual é uma 
<a href="#function.closures">Closure</a>.</p>
<p>Também deve ser notado que a chamada <code>new Bar()</code> <strong>não</strong> afeta o <code>prototype</code> 
do objeto retornado. Enquanto o <code>prototype</code> será definido no novo objeto 
criado, <code>Bar</code> nunca retornará aquele novo objeto.</p>
<p>No exemplo acima, não existe diferença funcional entre usar ou não usar a 
palavra chave <code>new</code>.</p>
<h3 id="criando-novos-objetos-via-factories">Criando Novos Objetos via Factories</h3>
<p>Recomenda-se <strong>não</strong> usar <code>new</code>, pois esquecer o seu uso pode levar a erros.</p>
<p>A fim de criar um novo objeto, deve-se preferir usar uma <code>factory</code> e 
construir um objeto no interior dessa <code>factory</code>.</p>
<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}</code></pre>
<p>Enquanto o exemplo acima é robusto contra a falta da palavra chave <code>news</code> e 
certamente faz o uso de <a href="#function.closures">variáveis privadas</a> facilmente, 
ele vem com algumas desvantagens.</p>
<ol>
<li>Usa mais memória, já que os objetos criados <strong>não</strong> compartilham os 
métodos em um <code>prototype</code>.</li>
<li>Em relação à herança, a <code>factory</code> precisa copiar todos os métodos de outro 
objeto ou colocar esse objeto no <code>prototype</code> do novo objeto.</li>
<li>Descartando a herança <code>prototype</code> apenas por causa de uma palavra
chave <code>new</code> é contrário ao espírito da linguagem.</li>
</ol>
<h3 id="conclus-o">Conclusão</h3>
<p>Embora omitir a palavra chave <code>new</code> pode-se levar a erros, certamente 
<strong>não</strong> é uma razão para abandonar o uso dos <code>prototypes</code> completamente. No 
fim, tudo se resume a qual solução é mais adequada para as necessidades da
aplicação. É especialmente importante escolher um estilo específico de 
criação de objetos e utilizá-lo consistentemente.</p>
</div></article><article id="function.scopes"><h2>Scopes and Namespaces</h2><div><p>Although JavaScript deals fine with the syntax of two matching curly
braces for blocks, it does <strong>not</strong> support block scope; hence, all that is left 
in the language is <em>function scope</em>.</p>
<pre><code>function test() { // a scope
    for(var i = 0; i &lt; 10; i++) { // not a scope
        // count
    }
    console.log(i); // 10
}</code></pre>
<aside>
<p><strong>Note:</strong> When not used in an assignment, return statement or as a function 
argument, the <code>{...}</code> notation will get interpreted as a block statement and 
<strong>not</strong> as an object literal. This, in conjunction with 
<a href="#core.semicolon">automatic insertion of semicolons</a>, can lead to subtle errors.</p>
</aside>
<p>There are also no distinct namespaces in JavaScript, which means that everything 
gets defined in one <em>globally shared</em> namespace.</p>
<p>Each time a variable is referenced, JavaScript will traverse upwards through all 
the scopes until it finds it. In the case that it reaches the global scope and 
still has not found the requested name, it will raise a <code>ReferenceError</code>.</p>
<h3 id="the-bane-of-global-variables">The Bane of Global Variables</h3>
<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;</code></pre>
<p>The above two scripts do <strong>not</strong> have the same effect. Script A defines a 
variable called <code>foo</code> in the <em>global</em> scope, and script B defines a <code>foo</code> in the
<em>current</em> scope.</p>
<p>Again, that is <strong>not</strong> at all the <em>same effect</em>: not using <code>var</code> can have major 
implications.</p>
<pre><code>// global scope
var foo = 42;
function test() {
    // local scope
    foo = 21;
}
test();
foo; // 21</code></pre>
<p>Leaving out the <code>var</code> statement inside the function <code>test</code> will override the 
value of <code>foo</code>. While this might not seem like a big deal at first, having 
thousands of lines of JavaScript and not using <code>var</code> will introduce horrible,
hard-to-track-down bugs.</p>
<pre><code>// global scope
var items = [/* some list */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // scope of subLoop
    for(i = 0; i &lt; 10; i++) { // missing var statement
        // do amazing stuff!
    }
}</code></pre>
<p>The outer loop will terminate after the first call to <code>subLoop</code>,  since <code>subLoop</code>
overwrites the global value of <code>i</code>. Using a <code>var</code> for the second <code>for</code> loop would
have easily avoided this error. The <code>var</code> statement should <strong>never</strong> be left out 
unless the <em>desired effect</em> is to affect the outer scope.</p>
<h3 id="local-variables">Local Variables</h3>
<p>The only source for local variables in JavaScript are
<a href="#function.general">function</a> parameters and variables declared via the 
<code>var</code> statement.</p>
<pre><code>// global scope
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // local scope of the function test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);</code></pre>
<p>While <code>foo</code> and <code>i</code> are local variables inside the scope of the function <code>test</code>,
the assignment of <code>bar</code> will override the global variable with the same name.</p>
<h3 id="hoisting">Hoisting</h3>
<p>JavaScript <strong>hoists</strong> declarations. This means that both <code>var</code> statements and
<code>function</code> declarations will be moved to the top of their enclosing scope.</p>
<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}</code></pre>
<p>The above code gets transformed before execution starts. JavaScript moves
the <code>var</code> statements, as well as <code>function</code> declarations, to the top of the 
nearest surrounding scope.</p>
<pre><code>// var statements got moved here
var bar, someValue; // default to &#39;undefined&#39;

// the function declaration got moved up too
function test(data) {
    var goo, i, e; // missing block scope moves these here
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // fails with a TypeError since bar is still &#39;undefined&#39;
someValue = 42; // assignments are not affected by hoisting
bar = function() {};

test();</code></pre>
<p>Missing block scoping will not only move <code>var</code> statements out of loops and
their bodies, it will also make the results of certain <code>if</code> constructs 
non-intuitive.</p>
<p>In the original code, although the <code>if</code> statement seemed to modify the <em>global 
variable</em> <code>goo</code>, it actually modifies the <em>local variable</em> - after hoisting 
has been applied.</p>
<p>Without knowledge of <em>hoisting</em>, one might suspect the code below would raise a
<code>ReferenceError</code>.</p>
<pre><code>// check whether SomeImportantThing has been initialized
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}</code></pre>
<p>But of course, this works due to the fact that the <code>var</code> statement is being 
moved to the top of the <em>global scope</em>.</p>
<pre><code>var SomeImportantThing;

// other code might initialize SomeImportantThing here, or not

// make sure it&#39;s there
if (!SomeImportantThing) {
    SomeImportantThing = {};
}</code></pre>
<h3 id="name-resolution-order">Name Resolution Order</h3>
<p>All scopes in JavaScript, including the <em>global scope</em>, have the special name 
<a href="#function.this"><code>this</code></a>, defined in them, which refers to the <em>current object</em>. </p>
<p>Function scopes also have the name <a href="#function.arguments"><code>arguments</code></a>, defined in
them, which contains the arguments that were passed to the function.</p>
<p>For example, when trying to access a variable named <code>foo</code> inside the scope of a 
function, JavaScript will look up the name in the following order:</p>
<ol>
<li>In case there is a <code>var foo</code> statement in the current scope, use that.</li>
<li>If one of the function parameters is named <code>foo</code>, use that.</li>
<li>If the function itself is called <code>foo</code>, use that.</li>
<li>Go to the next outer scope, and start with <strong>#1</strong> again.</li>
</ol>
<aside>
<p><strong>Note:</strong> Having a parameter called <code>arguments</code> will <strong>prevent</strong> the creation 
of the default <code>arguments</code> object.</p>
</aside>
<h3 id="namespaces">Namespaces</h3>
<p>A common problem associated with having only one global namespace is the
likelihood of running into problems where variable names clash. In JavaScript,
this problem can easily be avoided with the help of <em>anonymous wrappers</em>.</p>
<pre><code>(function() {
    // a self contained &quot;namespace&quot;

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately</code></pre>
<p>Unnamed functions are considered <a href="#function.general">expressions</a>; so in order to
be callable, they must first be evaluated.</p>
<pre><code>( // evaluate the function inside the parentheses
function() {}
) // and return the function object
() // call the result of the evaluation</code></pre>
<p>There are other ways to evaluate and directly call the function expression
which, while different in syntax, behave the same way.</p>
<pre><code>// A few other styles for directly invoking the 
!function(){}()
+function(){}()
(function(){}());
// and so on...</code></pre>
<h3 id="in-conclusion">In Conclusion</h3>
<p>It is recommended to always use an <em>anonymous wrapper</em> to encapsulate code in 
its own namespace. This does not only protect code against name clashes, but it 
also allows for better modularization of programs.</p>
<p>Additionally, the use of global variables is considered <strong>bad practice</strong>. <strong>Any</strong>
use of them indicates badly written code that is prone to errors and hard to maintain.</p>
</div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Arrays</h1></header><!-- Articles--><article id="array.general"><h2>Array Iteration and Properties</h2><div><p>Although arrays in JavaScript are objects, there are no good reasons to use
the <a href="#object.forinloop"><code>for in</code></a> loop. In fact, there 
are a number of good reasons <strong>against</strong> the use of <code>for in</code> on arrays.</p>
<aside>
<p><strong>Note:</strong> JavaScript arrays are <strong>not</strong> <em>associative arrays</em>. JavaScript only 
has <a href="#object.general">objects</a> for mapping keys to values. And while associative 
arrays <strong>preserve</strong> order, objects <strong>do not</strong>.</p>
</aside>
<p>Because the <code>for in</code> loop enumerates all the properties that are on the prototype 
chain and because the only way to exclude those properties is to use 
<a href="#object.hasownproperty"><code>hasOwnProperty</code></a>, it is already up to <strong>twenty times</strong> 
slower than a normal <code>for</code> loop.</p>
<h3 id="iteration">Iteration</h3>
<p>In order to achieve the best performance when iterating over arrays, it is best
to use the classic <code>for</code> loop.</p>
<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}</code></pre>
<p>There is one extra catch in the above example, which is the caching of the 
length of the array via <code>l = list.length</code>.</p>
<p>Although the <code>length</code> property is defined on the array itself, there is still an
overhead for doing the lookup on each iteration of the loop. And while recent 
JavaScript engines <strong>may</strong> apply optimization in this case, there is no way of
telling whether the code will run on one of these newer engines or not. </p>
<p>In fact, leaving out the caching may result in the loop being only <strong>half as
fast</strong> as with the cached length.</p>
<h3 id="the-length-property">The <code>length</code> Property</h3>
<p>While the <em>getter</em> of the <code>length</code> property simply returns the number of
elements that are contained in the array, the <em>setter</em> can be used to 
<strong>truncate</strong> the array.</p>
<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo.push(4);
foo; // [1, 2, 3, undefined, undefined, undefined, 4]</code></pre>
<p>Assigning a smaller length truncates the array. Increasing it creates a sparse array.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p>For the best performance, it is recommended to always use the plain <code>for</code> loop
and cache the <code>length</code> property. The use of <code>for in</code> on an array is a sign of
badly written code that is prone to bugs and bad performance. </p>
</div></article><article id="array.constructor"><h2>The <code>Array</code> Constructor</h2><div><p>Since the <code>Array</code> constructor is ambiguous in how it deals with its parameters,
it is highly recommended to use the array literal - <code>[]</code> notation - 
when creating new arrays.</p>
<pre><code>[1, 2, 3]; // Result: [1, 2, 3]
new Array(1, 2, 3); // Result: [1, 2, 3]

[3]; // Result: [3]
new Array(3); // Result: []
new Array(&#39;3&#39;) // Result: [&#39;3&#39;]</code></pre>
<p>In cases when there is only one argument passed to the <code>Array</code> constructor
and when that argument is a <code>Number</code>, the constructor will return a new <em>sparse</em> 
array with the <code>length</code> property set to the value of the argument. It should be 
noted that <strong>only</strong> the <code>length</code> property of the new array will be set this way; 
the actual indexes of the array will not be initialized. </p>
<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, the index was not set</code></pre>
<p>Being able to set the length of the array in advance is only useful in a few
cases, like repeating a string, in which it avoids the use of a loop.</p>
<pre><code>new Array(count + 1).join(stringToRepeat);</code></pre>
<h3 id="in-conclusion">In Conclusion</h3>
<p>Literals are preferred to the Array constructor. They are shorter, have a clearer syntax, and increase code
readability.</p>
</div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Types</h1></header><!-- Articles--><article id="types.equality"><h2>Equality and Comparisons</h2><div><p>JavaScript has two different ways of comparing the values of objects for equality. </p>
<h3 id="the-equality-operator">The Equality Operator</h3>
<p>The equality operator consists of two equal signs: <code>==</code></p>
<p>JavaScript features <em>weak typing</em>. This means that the equality operator 
<strong>coerces</strong> types in order to compare them.</p>
<pre><code>&quot;&quot;           ==   &quot;0&quot;           // false
0            ==   &quot;&quot;            // true
0            ==   &quot;0&quot;           // true
false        ==   &quot;false&quot;       // false
false        ==   &quot;0&quot;           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
&quot; \t\r\n&quot;    ==   0             // true</code></pre>
<p>The above table shows the results of the type coercion, and it is the main reason 
why the use of <code>==</code> is widely regarded as bad practice. It introduces
hard-to-track-down bugs due to its complicated conversion rules.</p>
<p>Additionally, there is also a performance impact when type coercion is in play;
for example, a string has to be converted to a number before it can be compared
to another number.</p>
<h3 id="the-strict-equality-operator">The Strict Equality Operator</h3>
<p>The strict equality operator consists of <strong>three</strong> equal signs: <code>===</code>.</p>
<p>It works like the normal equality operator, except that strict equality 
operator does <strong>not</strong> perform type coercion between its operands.</p>
<pre><code>&quot;&quot;           ===   &quot;0&quot;           // false
0            ===   &quot;&quot;            // false
0            ===   &quot;0&quot;           // false
false        ===   &quot;false&quot;       // false
false        ===   &quot;0&quot;           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
&quot; \t\r\n&quot;    ===   0             // false</code></pre>
<p>The above results are a lot clearer and allow for early breakage of code. This
hardens code to a certain degree and also gives performance improvements in case
the operands are of different types.</p>
<h3 id="comparing-objects">Comparing Objects</h3>
<p>While both <code>==</code> and <code>===</code> are called <strong>equality</strong> operators, they behave 
differently when at least one of their operands is an <code>Object</code>.</p>
<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true</code></pre>
<p>Here, both operators compare for <strong>identity</strong> and <strong>not</strong> equality; that is, they
will compare for the same <strong>instance</strong> of the object, much like <code>is</code> in Python 
and pointer comparison in C.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p>It is highly recommended to only use the <strong>strict equality</strong> operator. In cases
where types need to be coerced, it should be done <a href="#types.casting">explicitly</a> 
and not left to the language&#39;s complicated coercion rules.</p>
</div></article><article id="types.typeof"><h2>The <code>typeof</code> Operator</h2><div><p>The <code>typeof</code> operator (together with 
<a href="#types.instanceof"><code>instanceof</code></a>) is probably the biggest 
design flaw of JavaScript, as it is almost <strong>completely broken</strong>.</p>
<p>Although <code>instanceof</code> still has limited uses, <code>typeof</code> really has only one
practical use case, which does <strong>not</strong> happen to be checking the type of an 
object. </p>
<aside>
<p><strong>Note:</strong> While <code>typeof</code> can also be called with a function like syntax, i.e.
<code>typeof(obj)</code>, this is not a function call. The parentheses behave as normal
and the return value will be used as the operand of the <code>typeof</code> operator.
There is <strong>no</strong> <code>typeof</code> function.</p>
</aside>
<h3 id="the-javascript-type-table">The JavaScript Type Table</h3>
<pre><code>Value               Class      Type
-------------------------------------
&quot;foo&quot;               String     string
new String(&quot;foo&quot;)   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function(&quot;&quot;)    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object</code></pre>
<p>In the above table, <em>Type</em> refers to the value that the <code>typeof</code> operator returns.
As can be clearly seen, this value is anything but consistent.</p>
<p>The <em>Class</em> refers to the value of the internal <code>[[Class]]</code> property of an object.</p>
<aside>
<p><strong>From the Specification:</strong> The value of <code>[[Class]]</code> can be one of the
following strings. <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, 
<code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>
<p>In order to retrieve the value of <code>[[Class]]</code>, one has to make use of the
<code>toString</code> method of <code>Object.prototype</code>.</p>
<h3 id="the-class-of-an-object">The Class of an Object</h3>
<p>The specification gives exactly one way of accessing the <code>[[Class]]</code> value,
with the use of <code>Object.prototype.toString</code>. </p>
<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true</code></pre>
<p>In the above example, <code>Object.prototype.toString</code> gets called with the value of
<a href="#function.this">this</a> being set to the object whose <code>[[Class]]</code> value should be 
retrieved.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> For convenience the return value of <code>Object.prototype.toString</code> 
for both <code>null</code> and <code>undefined</code> was <strong>changed</strong> from <code>Object</code> to <code>Null</code> and 
<code>Undefined</code> in ECMAScript 5.</p>
</aside>
<h3 id="testing-for-undefined-variables">Testing for Undefined Variables</h3>
<pre><code>typeof foo !== &#39;undefined&#39;</code></pre>
<p>The above will check whether <code>foo</code> was actually declared or not; just 
referencing it would result in a <code>ReferenceError</code>. This is the only thing
<code>typeof</code> is actually useful for.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p>In order to check the type of an object, it is highly recommended to use 
<code>Object.prototype.toString</code> because this is the only reliable way of doing so. 
As shown in the above type table, some return values of <code>typeof</code> are not defined 
in the specification; thus, they can differ between implementations.</p>
<p>Unless checking whether a variable is defined, <code>typeof</code> should be avoided.</p>
</div></article><article id="types.instanceof"><h2>The <code>instanceof</code> Operator</h2><div><p>The <code>instanceof</code> operator compares the constructors of its two operands. It is 
only useful when comparing custom made objects. Used on built-in types, it is
nearly as useless as the <a href="#types.typeof">typeof operator</a>.</p>
<h3 id="comparing-custom-objects">Comparing Custom Objects</h3>
<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// This just sets Bar.prototype to the function object Foo,
// but not to an actual instance of Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false</code></pre>
<h3 id="using-instanceof-with-native-types">Using <code>instanceof</code> with Native Types</h3>
<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false</code></pre>
<p>One important thing to note here is that <code>instanceof</code> does not work on objects 
that originate from different JavaScript contexts (e.g. different documents
in a web browser), since their constructors will not be the exact same object.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p>The <code>instanceof</code> operator should <strong>only</strong> be used when dealing with custom made 
objects that originate from the same JavaScript context. Just like the
<a href="#types.typeof"><code>typeof</code></a> operator, every other use of it should be <strong>avoided</strong>.</p>
</div></article><article id="types.casting"><h2>Type Casting</h2><div><p>JavaScript is a <em>weakly typed</em> language, so it will apply <em>type coercion</em>
<strong>wherever</strong> possible.</p>
<pre><code>// These are true
new Number(10) == 10; // Number.toString() is converted
                      // back to a number

10 == &#39;10&#39;;           // Strings gets converted to Number
10 == &#39;+10 &#39;;         // More string madness
10 == &#39;010&#39;;          // And more 
isNaN(null) == false; // null converts to 0
                      // which of course is not NaN

// These are false
10 == 010;
10 == &#39;-10&#39;;</code></pre>
<aside class="es5"><p><strong>ES5 Note:</strong> Number literals that start with a <code>0</code> are interpreted as octal 
(Base 8). Octal support for these has been <strong>removed</strong> in ECMAScript 5 strict 
mode.</p>
</aside>
<p>To avoid the issues above, use of the <a href="#types.equality">strict equal operator</a> 
is <strong>highly</strong> recommended. Although this avoids a lot of common pitfalls, there 
are still many further issues that arise from JavaScript&#39;s weak typing system.</p>
<h3 id="constructors-of-built-in-types">Constructors of Built-In Types</h3>
<p>The constructors of the built in types like <code>Number</code> and <code>String</code> behave
differently when being used with the <code>new</code> keyword and without it.</p>
<pre><code>new Number(10) === 10;     // False, Object and Number
Number(10) === 10;         // True, Number and Number
new Number(10) + 0 === 10; // True, due to implicit conversion</code></pre>
<p>Using a built-in type like <code>Number</code> as a constructor will create a new <code>Number</code> 
object, but leaving out the <code>new</code> keyword will make the <code>Number</code> function behave
like a converter.</p>
<p>In addition, passing literals or non-object values will result in even more
type coercion.</p>
<p>The best option is to cast to one of the three possible types <strong>explicitly</strong>.</p>
<h3 id="casting-to-a-string">Casting to a String</h3>
<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true</code></pre>
<p>By prepending an empty string, a value can easily be cast to a string.</p>
<h3 id="casting-to-a-number">Casting to a Number</h3>
<pre><code>+&#39;10&#39; === 10; // true</code></pre>
<p>Using the <strong>unary</strong> plus operator, it is possible to cast to a number.</p>
<h3 id="casting-to-a-boolean">Casting to a Boolean</h3>
<p>By using the <strong>not</strong> operator twice, a value can be converted a boolean.</p>
<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true</code></pre>
</div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Core</h1></header><!-- Articles--><article id="core.eval"><h2>Why Not to Use <code>eval</code></h2><div><p>The <code>eval</code> function will execute a string of JavaScript code in the local scope.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1</code></pre>
<p>However, <code>eval</code> only executes in the local scope when it is being called
directly <em>and</em> when the name of the called function is actually <code>eval</code>.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3</code></pre>
<p>The use of <code>eval</code> should be avoided. 99.9% of its &quot;uses&quot; can be achieved
<strong>without</strong> it.</p>
<h3 id="-eval-in-disguise"><code>eval</code> in Disguise</h3>
<p>The <a href="#other.timeouts">timeout functions</a> <code>setTimeout</code> and <code>setInterval</code> can both 
take a string as their first argument. This string will <strong>always</strong> get executed 
in the global scope since <code>eval</code> is not being called directly in that case.</p>
<h3 id="security-issues">Security Issues</h3>
<p><code>eval</code> also is a security problem, because it executes <strong>any</strong> code given to it.
It should <strong>never</strong> be used with strings of unknown or untrusted origins.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p><code>eval</code> should never be used. Any code that makes use of it should be questioned
in its workings, performance and security. If something requires <code>eval</code> in
order to work, it should <strong>not</strong> be used in the first place.  A <em>better design</em>
should be used, that does not require the use of <code>eval</code>.</p>
</div></article><article id="core.undefined"><h2><code>undefined</code> and <code>null</code></h2><div><p>JavaScript has two distinct values for nothing, <code>null</code> and <code>undefined</code>, with
the latter being more useful.</p>
<h3 id="the-value-undefined-">The Value <code>undefined</code></h3>
<p><code>undefined</code> is a type with exactly one value: <code>undefined</code>.</p>
<p>The language also defines a global variable that has the value of <code>undefined</code>;
this variable is also called <code>undefined</code>. However, this variable is <strong>neither</strong> a constant
nor a keyword of the language. This means that its <em>value</em> can be easily 
overwritten.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> <code>undefined</code> in ECMAScript 5 is <strong>no longer</strong> <em>writable</em> in strict
mode, but its name can still be shadowed by for example a function with the name 
<code>undefined</code>.</p>
</aside>
<p>Here are some examples of when the value <code>undefined</code> is returned:</p>
<ul>
<li>Accessing the (unmodified) global variable <code>undefined</code>.</li>
<li>Accessing a declared <em>but not</em> yet initialized variable.</li>
<li>Implicit returns of functions due to missing <code>return</code> statements.</li>
<li><code>return</code> statements that do not explicitly return anything.</li>
<li>Lookups of non-existent properties.</li>
<li>Function parameters that do not have any explicit value passed.</li>
<li>Anything that has been set to the value of <code>undefined</code>.</li>
<li>Any expression in the form of <code>void(expression)</code></li>
</ul>
<h3 id="handling-changes-to-the-value-of-undefined-">Handling Changes to the Value of <code>undefined</code></h3>
<p>Since the global variable <code>undefined</code> only holds a copy of the actual <em>value</em> of 
<code>undefined</code>, assigning a new value to it does <strong>not</strong> change the value of the 
<em>type</em> <code>undefined</code>.</p>
<p>Still, in order to compare something against the value of <code>undefined</code>, it is
necessary to retrieve the value of <code>undefined</code> first.</p>
<p>To protect code against a possible overwritten <code>undefined</code> variable, a common
technique used is to add an additional parameter to an <a href="#function.scopes">anonymous
wrapper</a> that gets no argument passed to it.</p>
<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // undefined in the local scope does 
    // now again refer to the value `undefined`

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Another way to achieve the same effect would be to use a declaration inside the 
wrapper.</p>
<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);</code></pre>
<p>The only difference here is that this version results in 4 more bytes being
used in case it is minified, and there is no other <code>var</code> statement inside the
anonymous wrapper.</p>
<h3 id="uses-of-null-">Uses of <code>null</code></h3>
<p>While <code>undefined</code> in the context of the JavaScript language is mostly used in
the sense of a traditional <em>null</em>, the actual <code>null</code> (both a literal and a type)
is more or less just another data type.</p>
<p>It is used in some JavaScript internals (like declaring the end of the
prototype chain by setting <code>Foo.prototype = null</code>), but in almost all cases, it
can be replaced by <code>undefined</code>.</p>
</div></article><article id="core.semicolon"><h2>Automatic Semicolon Insertion</h2><div><p>Although JavaScript has C style syntax, it does <strong>not</strong> enforce the use of
semicolons in the source code, so it is possible to omit them.</p>
<p>JavaScript is not a semicolon-less language. In fact, it needs the 
semicolons in order to understand the source code. Therefore, the JavaScript
parser <strong>automatically</strong> inserts them whenever it encounters a parse
error due to a missing semicolon.</p>
<pre><code>var foo = function() {
} // parse error, semicolon expected
test()</code></pre>
<p>Insertion happens, and the parser tries again.</p>
<pre><code>var foo = function() {
}; // no error, parser continues
test()</code></pre>
<p>The automatic insertion of semicolon is considered to be one of <strong>biggest</strong>
design flaws in the language because it <em>can</em> change the behavior of code.</p>
<h3 id="how-it-works">How it Works</h3>
<p>The code below has no semicolons in it, so it is up to the parser to decide where
to insert them.</p>
<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)</code></pre>
<p>Below is the result of the parser&#39;s &quot;guessing&quot; game.</p>
<pre><code>(function(window, undefined) {
    function test(options) {

        // Not inserted, lines got merged
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- inserted

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- inserted

        return; // &lt;- inserted, breaks the return statement
        { // treated as a block

            // a label and a single expression statement
            foo: function() {} 
        }; // &lt;- inserted
    }
    window.test = test; // &lt;- inserted

// The lines got merged again
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- inserted

})(window); //&lt;- inserted</code></pre>
<aside>
<p><strong>Note:</strong> The JavaScript parser does not &quot;correctly&quot; handle return statements 
that are followed by a new line. While this is not necessarily the fault of
the automatic semicolon insertion, it can still be an unwanted side-effect. </p>
</aside>
<p>The parser drastically changed the behavior of the code above. In certain cases,
it does the <strong>wrong thing</strong>.</p>
<h3 id="leading-parenthesis">Leading Parenthesis</h3>
<p>In case of a leading parenthesis, the parser will <strong>not</strong> insert a semicolon.</p>
<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})</code></pre>
<p>This code gets transformed into one line.</p>
<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})</code></pre>
<p>Chances are <strong>very</strong> high that <code>log</code> does <strong>not</strong> return a function; therefore,
the above will yield a <code>TypeError</code> stating that <code>undefined is not a function</code>.</p>
<h3 id="in-conclusion">In Conclusion</h3>
<p>It is highly recommended to <strong>never</strong> omit semicolons. It is also recommended
that braces be kept on the same line as their corresponding statements and to
never omit them for single-line <code>if</code> / <code>else</code> statements. These measures will
not only improve the consistency of the code, but they will also prevent the
JavaScript parser from changing code behavior.</p>
</div></article><article id="core.delete"><h2>The <code>delete</code> Operator</h2><div><p>In short, it&#39;s <em>impossible</em> to delete global variables, functions and some other
stuff in JavaScript which have a <code>DontDelete</code> attribute set.</p>
<h3 id="global-code-and-function-code">Global code and Function code</h3>
<p>When a variable or a function is defined in a global or a <a href="#function.scopes">function
scope</a> it is a property of either the Activation object or
the Global object. Such properties have a set of attributes, one of which is
<code>DontDelete</code>. Variable and function declarations in global and function code
always create properties with <code>DontDelete</code>, and therefore cannot be deleted.</p>
<pre><code>// global variable:
var a = 1; // DontDelete is set
delete a; // false
a; // 1

// normal function:
function f() {} // DontDelete is set
delete f; // false
typeof f; // &quot;function&quot;

// reassigning doesn&#39;t help:
f = 1;
delete f; // false
f; // 1</code></pre>
<h3 id="explicit-properties">Explicit properties</h3>
<p>Explicitly set properties can be deleted normally.</p>
<pre><code>// explicitly set property:
var obj = {x: 1};
obj.y = 2;
delete obj.x; // true
delete obj.y; // true
obj.x; // undefined
obj.y; // undefined</code></pre>
<p>In the example above, <code>obj.x</code> and <code>obj.y</code> can be deleted because they have no 
<code>DontDelete</code> atribute. That&#39;s why the example below works too.</p>
<pre><code>// this works fine, except for IE:
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // true - just a global var
delete GLOBAL_OBJECT.a; // true
GLOBAL_OBJECT.a; // undefined</code></pre>
<p>Here we use a trick to delete <code>a</code>. <a href="#function.this"><code>this</code></a> here refers 
to the Global object and we explicitly declare variable <code>a</code> as its property 
which allows us to delete it.</p>
<p>IE (at least 6-8) has some bugs, so the code above doesn&#39;t work.</p>
<h3 id="function-arguments-and-built-ins">Function arguments and built-ins</h3>
<p>Functions&#39; normal arguments, <a href="#function.arguments"><code>arguments</code> objects</a> 
and built-in properties also have <code>DontDelete</code> set.</p>
<pre><code>// function arguments and properties:
(function (x) {

  delete arguments; // false
  typeof arguments; // &quot;object&quot;

  delete x; // false
  x; // 1

  function f(){}
  delete f.length; // false
  typeof f.length; // &quot;number&quot;

})(1);</code></pre>
<h3 id="host-objects">Host objects</h3>
<p>The behaviour of <code>delete</code> operator can be unpredictable for hosted objects. Due
to the specification, host objects are allowed to implement any kind of behavior. </p>
<h3 id="in-conclusion">In conclusion</h3>
<p>The <code>delete</code> operator often has unexpected behaviour and can only be safely
used to delete explicitly set properties on normal objects.</p>
</div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Outros</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> and <code>setInterval</code></h2><div><p>Since JavaScript is asynchronous, it is possible to schedule the execution of a 
function using the <code>setTimeout</code> and <code>setInterval</code> functions.</p>
<aside>
<p><strong>Note:</strong> Timeouts are <strong>not</strong> part of the ECMAScript Standard. They are
implemented as part of the <a href="http://en.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>.</p>
</aside>
<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // returns a Number &gt; 0</code></pre>
<p>When <code>setTimeout</code> is called, it returns the ID of the timeout and schedule
<code>foo</code> to run <strong>approximately</strong> one thousand milliseconds in the future. 
<code>foo</code> will then be executed <strong>once</strong>.</p>
<p>Depending on the timer resolution of the JavaScript engine running the code, as
well as the fact that JavaScript is single threaded and other code that gets
executed might block the thread, it is by <strong>no means</strong> a safe bet that one will
get the exact delay specified in the <code>setTimeout</code> call.</p>
<p>The function that was passed as the first parameter will get called by the
<em>global object</em>, which means that <a href="#function.this"><code>this</code></a> inside the called function 
refers to the global object.</p>
<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this refers to the global object
        console.log(this.value); // will log undefined
    };
    setTimeout(this.method, 500);
}
new Foo();</code></pre>
<aside>
<p><strong>Note:</strong> As <code>setTimeout</code> takes a <strong>function object</strong> as its first parameter, a
common mistake is to use <code>setTimeout(foo(), 1000)</code>, which will use the 
<strong>return value</strong> of the call <code>foo</code> and <strong>not</strong> <code>foo</code>. This is, most of the time, 
a silent error, since when the function returns <code>undefined</code> <code>setTimeout</code> will 
<strong>not</strong> raise any error.</p>
</aside>
<h3 id="stacking-calls-with-setinterval-">Stacking Calls with <code>setInterval</code></h3>
<p>While <code>setTimeout</code> only runs the function once, <code>setInterval</code> - as the name 
suggests - will execute the function <strong>every</strong> <code>X</code> milliseconds, but its use is 
discouraged. </p>
<p>When code that is being executed blocks the timeout call, <code>setInterval</code> will 
still issue more calls to the specified function. This can, especially with small
intervals, result in function calls stacking up.</p>
<pre><code>function foo(){
    // something that blocks for 1 second
}
setInterval(foo, 1000);</code></pre>
<p>In the above code, <code>foo</code> will get called once and will then block for one second.</p>
<p>While <code>foo</code> blocks the code, <code>setInterval</code> will still schedule further calls to
it. Now, when <code>foo</code> has finished, there will already be <strong>ten</strong> further calls to
it waiting for execution.</p>
<h3 id="dealing-with-possible-blocking-code">Dealing with Possible Blocking Code</h3>
<p>The easiest solution, as well as most controllable solution, is to use <code>setTimeout</code> within
the function itself.</p>
<pre><code>function foo(){
    // something that blocks for 1 second
    setTimeout(foo, 1000);
}
foo();</code></pre>
<p>Not only does this encapsulate the <code>setTimeout</code> call, but it also prevents the
stacking of calls and gives additional control. <code>foo</code> itself can now decide 
whether it wants to run again or not.</p>
<h3 id="manually-clearing-timeouts">Manually Clearing Timeouts</h3>
<p>Clearing timeouts and intervals works by passing the respective ID to
<code>clearTimeout</code> or <code>clearInterval</code>, depending on which <code>set</code> function was used
in the first place.</p>
<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);</code></pre>
<h3 id="clearing-all-timeouts">Clearing All Timeouts</h3>
<p>As there is no built-in method for clearing all timeouts and/or intervals, 
it is necessary to use brute force in order to achieve this functionality.</p>
<pre><code>// clear &quot;all&quot; timeouts
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}</code></pre>
<p>But there might still be timeouts that are unaffected by this arbitrary number.
Another way of doing this is to consider that the ID given to a timeout is
incremented by one every time you call <code>setTimeout</code>.</p>
<pre><code>// clear &quot;all&quot; timeouts
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}</code></pre>
<p>Even though this works on all major browsers today, it isn&#39;t specified that
the IDs should be ordered that way and it may change. Therefore, it is instead
recommended to keep track of all the timeout IDs, so they can be cleared
specifically.</p>
<h3 id="hidden-use-of-eval-">Hidden Use of <code>eval</code></h3>
<p><code>setTimeout</code> and <code>setInterval</code> can also take a string as their first parameter.
This feature should <strong>never</strong> be used because it internally makes use of <code>eval</code>.</p>
<aside>
<p><strong>Note:</strong> Since the timeout functions are <strong>not</strong> specified by the ECMAScript
standard, the exact workings when a string is passed to them might differ in
various JavaScript implementations. For example, Microsoft&#39;s JScript uses
the <code>Function</code> constructor in place of <code>eval</code>.</p>
</aside>
<pre><code>function foo() {
    // will get called
}

function bar() {
    function foo() {
        // never gets called
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();</code></pre>
<p>Since <code>eval</code> is not getting called <a href="#core.eval">directly</a> in this case, the string 
passed to <code>setTimeout</code> will be executed in the <em>global scope</em>; thus, it will 
not use the local variable <code>foo</code> from the scope of <code>bar</code>.</p>
<p>It is further recommended to <strong>not</strong> use a string to pass arguments to the
function that will get called by either of the timeout functions. </p>
<pre><code>function foo(a, b, c) {}

// NEVER use this
setTimeout(&#39;foo(1, 2, 3)&#39;, 1000)

// Instead use an anonymous function
setTimeout(function() {
    foo(a, b, c);
}, 1000)</code></pre>
<aside>
<p><strong>Note:</strong> While it is also possible to use the syntax 
<code>setTimeout(foo, 1000, a, b, c)</code>, it is not recommended, as its use may lead
to subtle errors when used with <a href="#function.this">methods</a>. </p>
</aside>
<h3 id="in-conclusion">In Conclusion</h3>
<p>A string should <strong>never</strong> be used as the parameter of <code>setTimeout</code> or 
<code>setInterval</code>. It is a clear sign of <strong>really</strong> bad code, when arguments need 
to be supplied to the function that gets called. An <em>anonymous function</em> should
be passed that then takes care of the actual call.</p>
<p>Furthermore, the use of <code>setInterval</code> should be avoided because its scheduler is not
blocked by executing JavaScript.</p>
</div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with
 <a href="http://nodejs.org/">Node.js </a>using a<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by <a href="http://cramerdev.com">Cramer Development</a>.</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/plugin.js"></script><script src="../javascript/garden.js"></script></body></html>